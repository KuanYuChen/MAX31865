; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\output\stm32_usart1.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\output\stm32_usart1.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\User -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\bsp_lib -IE:\keli\ARM\RV31\INC -IE:\keli\ARM\CMSIS\Include -IE:\keli\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\stm32_usart1.crf ..\bsp_lib\stm32_usart1.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  GPIO_Configuration PROC
;;;96     
;;;97     void GPIO_Configuration(void)
000000  b508              PUSH     {r3,lr}
;;;98     
;;;99     {
;;;100    
;;;101      GPIO_InitTypeDef GPIO_InitStructure;  //
;;;102    
;;;103      
;;;104      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); 
000002  2101              MOVS     r1,#1
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;105      
;;;106      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;      
00000a  f44f7000          MOV      r0,#0x200
00000e  f8ad0000          STRH     r0,[sp,#0]
;;;107    
;;;108      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;  
000012  2003              MOVS     r0,#3
000014  f88d0002          STRB     r0,[sp,#2]
;;;109    
;;;110      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  
000018  2018              MOVS     r0,#0x18
00001a  f88d0003          STRB     r0,[sp,#3]
;;;111    
;;;112      GPIO_Init(GPIOA, &GPIO_InitStructure);  
00001e  4669              MOV      r1,sp
000020  483a              LDR      r0,|L1.268|
000022  f7fffffe          BL       GPIO_Init
;;;113    
;;;114     
;;;115    
;;;116     
;;;117    
;;;118      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;  
000026  f44f6080          MOV      r0,#0x400
00002a  f8ad0000          STRH     r0,[sp,#0]
;;;119    
;;;120      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;  
00002e  2004              MOVS     r0,#4
000030  f88d0003          STRB     r0,[sp,#3]
;;;121    
;;;122      GPIO_Init(GPIOA, &GPIO_InitStructure);  
000034  4669              MOV      r1,sp
000036  4835              LDR      r0,|L1.268|
000038  f7fffffe          BL       GPIO_Init
;;;123    
;;;124    }
00003c  bd08              POP      {r3,pc}
;;;125    
                          ENDP

                  USART1_Configuration PROC
;;;126    void USART1_Configuration(void)
00003e  b51f              PUSH     {r0-r4,lr}
;;;127    {
;;;128      USART_InitTypeDef USART_InitStructure;
;;;129      
;;;130      USART_InitStructure.USART_BaudRate = 115200;                   //set baud rate
000040  f44f30e1          MOV      r0,#0x1c200
000044  9000              STR      r0,[sp,#0]
;;;131    
;;;132       USART_InitStructure.USART_WordLength = USART_WordLength_8b;    //set word length
000046  2000              MOVS     r0,#0
000048  f8ad0004          STRH     r0,[sp,#4]
;;;133    
;;;134       USART_InitStructure.USART_StopBits = USART_StopBits_1;        //set stop bit
00004c  f8ad0006          STRH     r0,[sp,#6]
;;;135    
;;;136       USART_InitStructure.USART_Parity = USART_Parity_No;        //set parity bit
000050  f8ad0008          STRH     r0,[sp,#8]
;;;137    
;;;138       USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; //No hardwareflow control
000054  f8ad000c          STRH     r0,[sp,#0xc]
;;;139    
;;;140       USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;//enable receive and send
000058  200c              MOVS     r0,#0xc
00005a  f8ad000a          STRH     r0,[sp,#0xa]
;;;141    
;;;142       USART_Init(USART1, &USART_InitStructure);                      
00005e  4669              MOV      r1,sp
000060  482b              LDR      r0,|L1.272|
000062  f7fffffe          BL       USART_Init
;;;143    
;;;144       USART_Cmd(USART1, ENABLE);    // enable USART1
000066  2101              MOVS     r1,#1
000068  4829              LDR      r0,|L1.272|
00006a  f7fffffe          BL       USART_Cmd
;;;145    
;;;146    }
00006e  bd1f              POP      {r0-r4,pc}
;;;147    
                          ENDP

                  USART1_Init PROC
;;;148    void USART1_Init(void)
000070  b510              PUSH     {r4,lr}
;;;149    {
;;;150     RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1| RCC_APB2Periph_AFIO, ENABLE);  
000072  2101              MOVS     r1,#1
000074  f2440001          MOV      r0,#0x4001
000078  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;151     GPIO_Configuration();
00007c  f7fffffe          BL       GPIO_Configuration
;;;152     USART1_Configuration();
000080  f7fffffe          BL       USART1_Configuration
;;;153    }
000084  bd10              POP      {r4,pc}
;;;154    
                          ENDP

                  USART1_SendByte PROC
;;;155    void USART1_SendByte(uint8_t data)
000086  b510              PUSH     {r4,lr}
;;;156    {
000088  4604              MOV      r4,r0
;;;157       while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET);
00008a  bf00              NOP      
                  |L1.140|
00008c  2140              MOVS     r1,#0x40
00008e  4820              LDR      r0,|L1.272|
000090  f7fffffe          BL       USART_GetFlagStatus
000094  2800              CMP      r0,#0
000096  d0f9              BEQ      |L1.140|
;;;158       USART_SendData(USART1, data);
000098  4621              MOV      r1,r4
00009a  481d              LDR      r0,|L1.272|
00009c  f7fffffe          BL       USART_SendData
;;;159       while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET);// 
0000a0  bf00              NOP      
                  |L1.162|
0000a2  2140              MOVS     r1,#0x40
0000a4  481a              LDR      r0,|L1.272|
0000a6  f7fffffe          BL       USART_GetFlagStatus
0000aa  2800              CMP      r0,#0
0000ac  d0f9              BEQ      |L1.162|
;;;160    }
0000ae  bd10              POP      {r4,pc}
;;;161    
                          ENDP

                  USART1_SendString PROC
;;;162    void USART1_SendString(char *s)
0000b0  e92d41f0          PUSH     {r4-r8,lr}
;;;163    {
0000b4  4604              MOV      r4,r0
;;;164      uint16_t length,i;
;;;165      char *pointer;
;;;166      char x;
;;;167      
;;;168      length = strlen(s);
0000b6  4620              MOV      r0,r4
0000b8  f7fffffe          BL       strlen
0000bc  fa1ff880          UXTH     r8,r0
;;;169      pointer=s;
0000c0  4626              MOV      r6,r4
;;;170      for(i=0;i<length;i++)
0000c2  2500              MOVS     r5,#0
0000c4  e006              B        |L1.212|
                  |L1.198|
;;;171      {  x=*pointer;
0000c6  7837              LDRB     r7,[r6,#0]
;;;172         USART1_SendByte(x);
0000c8  4638              MOV      r0,r7
0000ca  f7fffffe          BL       USART1_SendByte
;;;173         pointer++;
0000ce  1c76              ADDS     r6,r6,#1
0000d0  1c68              ADDS     r0,r5,#1              ;170
0000d2  b285              UXTH     r5,r0                 ;170
                  |L1.212|
0000d4  4545              CMP      r5,r8                 ;170
0000d6  dbf6              BLT      |L1.198|
;;;174        
;;;175      }
;;;176      
;;;177    }
0000d8  e8bd81f0          POP      {r4-r8,pc}
;;;178    
                          ENDP

                  USART1_SendData PROC
;;;179    void USART1_SendData(uint8_t data)
0000dc  b570              PUSH     {r4-r6,lr}
;;;180    {
0000de  4604              MOV      r4,r0
;;;181     USART1_SendByte(data/16+'0');
0000e0  4625              MOV      r5,r4
0000e2  17e1              ASRS     r1,r4,#31
0000e4  eb047111          ADD      r1,r4,r1,LSR #28
0000e8  1109              ASRS     r1,r1,#4
0000ea  3130              ADDS     r1,r1,#0x30
0000ec  b2c8              UXTB     r0,r1
0000ee  f7fffffe          BL       USART1_SendByte
;;;182     USART1_SendByte(data%16+'0');
0000f2  4625              MOV      r5,r4
0000f4  17e1              ASRS     r1,r4,#31
0000f6  eb047111          ADD      r1,r4,r1,LSR #28
0000fa  1109              ASRS     r1,r1,#4
0000fc  eba41101          SUB      r1,r4,r1,LSL #4
000100  3130              ADDS     r1,r1,#0x30
000102  b2c8              UXTB     r0,r1
000104  f7fffffe          BL       USART1_SendByte
;;;183    }
000108  bd70              POP      {r4-r6,pc}
                          ENDP

00010a  0000              DCW      0x0000
                  |L1.268|
                          DCD      0x40010800
                  |L1.272|
                          DCD      0x40013800

;*** Start embedded assembler ***

#line 1 "..\\bsp_lib\\stm32_usart1.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___14_stm32_usart1_c_73aedecf____REV16|
#line 129 "E:\\keli\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___14_stm32_usart1_c_73aedecf____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___14_stm32_usart1_c_73aedecf____REVSH|
#line 144
|__asm___14_stm32_usart1_c_73aedecf____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
